<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ぷるんスライム（表情切替＋白背景自動抜き＋SE）</title>
<style>
  :root{ --tx:0px; --ty:0px; }
  body{
    margin:0; height:100svh; display:grid; place-items:center;
    background:#f6f7fb; font-family:system-ui,sans-serif; touch-action:manipulation;
  }
  .wrap{ position:relative; width:min(80vw,360px); aspect-ratio:1/1; display:grid; place-items:center; }
  img.slime{
    width:100%; height:auto; display:block; user-select:none; -webkit-user-drag:none;
    transform-origin:center center; filter: drop-shadow(0 12px 18px rgba(0,0,0,.15));
    transition:filter .2s ease;
  }
  .jiggle{ animation: squish .6s cubic-bezier(.2,.7,.2,1.2); transform: translate(var(--tx),var(--ty)); }
  @keyframes squish{
    0%{transform:translate(var(--tx),var(--ty)) scale(1,1)}
    20%{transform:translate(var(--tx),var(--ty)) scale(1.12,.88)}
    40%{transform:translate(calc(var(--tx)*.5),calc(var(--ty)*.5)) scale(.92,1.08)}
    60%{transform:translate(calc(var(--tx)*.2),calc(var(--ty)*.2)) scale(1.06,.94)}
    80%{transform:translate(0,0) scale(.98,1.02)}
    100%{transform:translate(0,0) scale(1,1)}
  }
  img.slime:active{ filter: drop-shadow(0 8px 12px rgba(0,0,0,.18)); }
</style>
</head>
<body>

<div class="wrap">
  <!-- 初期は1枚目を表示（後で自動で透過化して差し替えます） -->
  <img class="slime" id="slime" src="slime1.png" alt="スライム">
</div>

<script>
  // ===== 設定 =====
  const WHITE_TOLERANCE = 30;   // 白に近い色まで透明化（上げるほど広く抜ける）
  const FEATHER_BAND    = 18;   // ふちのフェザー幅
  const EXPRESSIONS     = ['slime1.png', 'slime2.png']; // 交互に切替
  const SE_FILE         = 'se_ploop.mp3'; // 効果音ファイル（同じフォルダに置く）

  // ===== DOM =====
  const slime = document.getElementById('slime');
  const wrap  = document.querySelector('.wrap');

  // ===== 効果音：同時連打でも遅延しないように小さな再生プール =====
  const sePool = Array.from({length:3}, () => {
    const a = new Audio(SE_FILE);
    a.preload = 'auto';
    a.volume = 0.8;   // 音量 0.0-1.0
    return a;
  });
  let seIndex = 0;
  function playSE(){
    const a = sePool[seIndex++ % sePool.length];
    try { a.currentTime = 0; a.play(); } catch(e) {/* ユーザー操作前などの再生ブロック対策 */}
  }

  // ===== 画像の透過化（白抜き）をキャッシュ =====
  const cache = new Map(); // filename -> dataURL

  function loadAndMakeTransparent(src){
    return new Promise((resolve, reject)=>{
      if (cache.has(src)) return resolve(cache.get(src));
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = ()=>{
        const w = img.naturalWidth, h = img.naturalHeight;
        const cv = document.createElement('canvas');
        cv.width = w; cv.height = h;
        const ctx = cv.getContext('2d', { willReadFrequently:true });
        ctx.drawImage(img, 0, 0);
        const data = ctx.getImageData(0,0,w,h);
        const px = data.data;

        for (let i=0;i<px.length;i+=4){
          const r=px[i], g=px[i+1], b=px[i+2], a=px[i+3];
          if (a === 0) continue;
          const dr = 255-r, dg = 255-g, db = 255-b;
          const d  = Math.sqrt(dr*dr + dg*dg + db*db);
          if (d <= WHITE_TOLERANCE){
            px[i+3] = 0;
          } else if (d <= WHITE_TOLERANCE + FEATHER_BAND){
            const t = (d - WHITE_TOLERANCE) / FEATHER_BAND; // 0..1
            px[i+3] = Math.round(a * t);
          }
        }
        ctx.putImageData(data,0,0);
        const url = cv.toDataURL('image/png');
        cache.set(src, url);
        resolve(url);
      };
      img.onerror = reject;
      img.src = src;
    });
  }

  // 初期プリロード（全表情を加工してキャッシュ）
  Promise.all(EXPRESSIONS.map(loadAndMakeTransparent)).then(urls=>{
    slime.src = urls[0]; // 初期も加工済みに差し替え
  });

  // ===== タッチ方向へ少しだけ寄せて“ぷるん” =====
  function setNudge(e){
    const rect = wrap.getBoundingClientRect();
    const cx = rect.left + rect.width/2;
    const cy = rect.top  + rect.height/2;
    const p  = ('touches' in e) ? e.touches[0] : e;
    const dx = p.clientX - cx;
    const dy = p.clientY - cy;
    const len = Math.hypot(dx,dy) || 1;
    const k = Math.min(10, len/10);
    document.documentElement.style.setProperty('--tx', (dx/len * k).toFixed(2)+'px');
    document.documentElement.style.setProperty('--ty', (dy/len * k).toFixed(2)+'px');
  }

  // ===== タップ毎に表情を交互切替 → ぷるん → SE =====
  let exprIndex = 0;
  async function ploop(e){
    setNudge(e);

    // 表情切替（交互）
    exprIndex = (exprIndex + 1) % EXPRESSIONS.length;
    const nextFile = EXPRESSIONS[exprIndex];
    const url = cache.get(nextFile) || await loadAndMakeTransparent(nextFile);
    slime.src = url;

    // ぷるん
    slime.classList.remove('jiggle');
    void slime.offsetWidth; // reflow
    slime.classList.add('jiggle');

    // 効果音
    playSE();
  }

  // PCクリック
  slime.addEventListener('mousedown', ploop);
  // スマホタッチ（ユーザー操作内なので自動再生の制限をクリア）
  slime.addEventListener('touchstart', (e)=>{ e.preventDefault(); ploop(e); }, {passive:false});
</script>

</body>
</html>
